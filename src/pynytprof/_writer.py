from __future__ import annotations

import os
import struct
import time
from pathlib import Path

from ._pywrite import _make_ascii_header, write as _py_write, Writer as _PyWriter


class Writer:
    """Pure Python NYTProf writer used when the C extension is unavailable."""

    def __init__(
        self,
        path: str,
        start_ns: int | None = None,
        ticks_per_sec: int = 10_000_000,
        tracer=None,
    ) -> None:
        self._path = Path(path)
        self._fh = None
        self.start_time = time.time_ns() if start_ns is None else start_ns
        self.ticks_per_sec = ticks_per_sec
        self._start_ns = self.start_time
        self.tracer = tracer
        self.writer = self
        self._line_hits: dict[tuple[int, int], tuple[int, int, int]] = {}
        self._buf: dict[bytes, bytearray] = {
            b"F": bytearray(),
            b"S": bytearray(),
            b"D": bytearray(),
            b"C": bytearray(),
        }
        if os.getenv("PYNYTPROF_DEBUG"):
            import sys

            print("DEBUG: Writer initialized with empty buffers", file=sys.stderr)

    def _buffer_chunk(self, tag: bytes, payload: bytes) -> None:
        if os.getenv("PYNYTPROF_DEBUG"):
            import sys

            print(
                f"DEBUG: buffering chunk tag={tag.decode()} len={len(payload)}",
                file=sys.stderr,
            )
        if payload:
            self._buf[tag].extend(payload)

    def record_line(self, fid: int, line: int, calls: int, inc: int, exc: int) -> None:
        self._line_hits[(fid, line)] = (calls, inc, exc)
        rec = struct.pack("<IIIQQ", fid, line, calls, inc, exc)
        self._buffer_chunk(b"S", rec)

    # expose the same API the C writer has
    def write_chunk(self, token: bytes, payload: bytes) -> None:  # noqa: D401 - simple delegate
        tag = token[:1]
        if tag in self._buf:
            self._buffer_chunk(tag, payload)
        elif tag == b"E":
            pass  # handled on close

    def __enter__(self) -> "Writer":
        self._fh = open(self._path, "wb")
        return self

    def __exit__(self, exc_type, exc, tb) -> None:
        self.close()

    def close(self) -> None:
        if not self._fh:
            return

        if self.tracer is not None:
            ns2ticks = lambda ns: ns // 100
            for line, calls in self.tracer._line_hits.items():
                rec = struct.pack(
                    "<IIIQQ",
                    0,
                    line,
                    calls,
                    ns2ticks(self.tracer._line_time_ns[line]),
                    ns2ticks(self.tracer._exc_time_ns.get(line, 0)),
                )
                self._buffer_chunk(b"S", rec)

        if not self._buf[b"S"]:
            recs = []
            for (fid, line), (calls, inc, exc) in self._line_hits.items():
                recs.append(struct.pack("<IIIQQ", fid, line, calls, inc, exc))
            if recs:
                self._buffer_chunk(b"S", b"".join(recs))

        if os.getenv("PYNYTPROF_DEBUG"):
            import sys

            summary = ", ".join(f"{t.decode()}={len(buf)}" for t, buf in self._buf.items())
            print(f"FINAL CHUNKS: {summary}", file=sys.stderr)

        try:
            hz = os.sysconf("SC_CLK_TCK")
        except (AttributeError, ValueError, OSError):
            hz = 100
        hdr_lines = [
            f"NYTProf {_MAJOR} {_MINOR}",
            f"#Perl profile database. Generated by Pynytprof on "
            f"{time.strftime('%a, %d %b %Y %H:%M:%S +0000', time.gmtime())}",
            f":basetime={int(self._start_ns // 1_000_000_000)}",
            ":application=-e",
            f":perl_version={sys.version.split()[0]}",
            ":nv_size=8",
            ":clock_mod=cpu",
            ":ticks_per_sec=10000000",
            f":osname={platform.system().lower()}",
            f":hz={hz}",
        ]
        static_hdr = "\n".join(hdr_lines) + "\n"
        size_of_static = len(static_hdr.encode())
        header_size = size_of_static + len(":header_size=00000\n")
        hdr = _make_ascii_header(static_hdr, header_size)
        hdr += b"\n"
        data = hdr
        if os.getenv("PYNYTPROF_DEBUG"):
            print(f"DEBUG: about to write raw data of length={len(data)}", file=sys.stderr)
        self._fh.write(data)
        for tag in [b"F", b"S", b"D", b"C", b"E"]:
            payload = self._buf.get(tag, b"") if tag != b"E" else b""
            if os.getenv("PYNYTPROF_DEBUG"):
                print(
                    f"DEBUG: emitting chunk tag={tag.decode()} len={len(payload)}", file=sys.stderr
                )
            data = tag
            if os.getenv("PYNYTPROF_DEBUG"):
                print(f"DEBUG: about to write raw data of length={len(data)}", file=sys.stderr)
            self._fh.write(data)
            data = len(payload).to_bytes(4, "little")
            if os.getenv("PYNYTPROF_DEBUG"):
                print(f"DEBUG: about to write raw data of length={len(data)}", file=sys.stderr)
            self._fh.write(data)
            data = payload
            if os.getenv("PYNYTPROF_DEBUG"):
                print(f"DEBUG: about to write raw data of length={len(data)}", file=sys.stderr)
            self._fh.write(data)

        if os.getenv("PYNYTPROF_DEBUG"):
            import sys

            print("DEBUG: all chunks emitted", file=sys.stderr)

        self._fh.close()
        self._fh = None


try:
    from . import _cwrite  # type: ignore
except Exception:  # pragma: no cover - optional extension
    _cwrite = None

if os.getenv("PYNYTPROF_WRITER") == "c" and _cwrite is not None:
    WRITER = _cwrite.Writer
    write = _cwrite.write  # type: ignore[attr-defined]
else:
    WRITER = _PyWriter
    write = _py_write

__all__ = ["write", "Writer", "WRITER"]
