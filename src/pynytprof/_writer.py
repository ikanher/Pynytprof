from __future__ import annotations

import os
import warnings

import importlib.metadata
import time
import struct
from pathlib import Path
import sys
import platform
import datetime
from email.utils import format_datetime

try:
    _version = importlib.metadata.version("pynytprof")
except importlib.metadata.PackageNotFoundError:  # pragma: no cover - dev env
    _version = "0"

_mode = os.environ.get("PYNYTPROF_WRITER", "auto")

if _mode == "py":
    _impl = None
elif _mode == "c":
    from . import _cwrite as _impl
    if getattr(_impl, "__build__", None) != _version:
        warnings.warn(
            "stale _cwrite extension; falling back to pure-Python writer",
            RuntimeWarning,
        )
        _impl = None
else:  # auto
    try:
        from . import _cwrite as _cimpl
    except Exception:
        _cimpl = None
    if _cimpl is not None and getattr(_cimpl, "__build__", None) == _version:
        _impl = _cimpl
    else:
        if _cimpl is not None and getattr(_cimpl, "__build__", None) != _version:
            warnings.warn(
                "stale _cwrite extension; falling back to pure-Python writer",
                RuntimeWarning,
            )
        _impl = None

if _impl is not None:
    write = _impl.write
    Writer = _impl.Writer
else:
    def _make_ascii_header(start_ns: int) -> bytes:
        now = format_datetime(datetime.datetime.now(datetime.timezone.utc))
        try:
            hz = os.sysconf("SC_CLK_TCK")  # type: ignore[arg-type]
        except (AttributeError, ValueError, OSError):
            hz = 100
        lines = [
            "NYTProf 5 0",
            f"#Perl profile database. Generated by Pynytprof on {now}",
            f":basetime={int(start_ns // 1_000_000_000)}",
            ":application=-e",
            f":perl_version={sys.version.split()[0]}",
            f":nv_size={struct.calcsize('d')}",
            ":clock_mod=cpu",
            ":ticks_per_sec=10000000",
            f":osname={platform.system().lower()}",
            f":hz={hz}",
            "!subs=1",
            "!blocks=0",
            "!leave=1",
            "!expand=0",
            "!trace=0",
            "!use_db_sub=0",
            "!compress=0",
            "!clock=1",
            "!stmts=1",
            "!slowops=2",
            "!findcaller=0",
            "!forkdepth=-1",
            "!perldb=0",
            "!nameevals=1",
            "!nameanonsubs=1",
            "!calls=1",
            "!evals=0",
        ]
        hdr = ("\n".join(lines) + "\n\n").encode()
        assert b"\0" not in hdr
        return hdr

    class Writer:
        def __init__(self, path: str, start_ns: int | None = None, ticks_per_sec: int = 10_000_000, tracer=None) -> None:
            self._path = Path(path)
            self._fh = None
            self._start_ns = time.time_ns() if start_ns is None else start_ns
            self.ticks_per_sec = ticks_per_sec
            self.tracer = tracer
            self._buf: dict[bytes, bytearray] = {
                b"F": bytearray(),
                b"S": bytearray(),
                b"D": bytearray(),
                b"C": bytearray(),
            }

        def write_chunk(self, token: bytes, payload: bytes) -> None:
            tag = token[:1]
            if tag in self._buf:
                self._buf[tag].extend(payload)

        def __enter__(self):
            self._fh = open(self._path, "wb")
            return self

        def __exit__(self, exc_type, exc, tb):
            self.close()

        def close(self) -> None:
            if not self._fh:
                return
            hdr = _make_ascii_header(self._start_ns)
            self._fh.write(hdr)
            for tag in [b"F", b"S", b"D", b"C", b"E"]:
                payload = self._buf.get(tag, b"") if tag != b"E" else b""
                self._fh.write(tag)
                self._fh.write(len(payload).to_bytes(4, "little"))
                if payload:
                    self._fh.write(payload)
            self._fh.close()
            self._fh = None

    def write(out_path: str, files, defs, calls, lines, start_ns: int, ticks_per_sec: int) -> None:
        with Writer(out_path, start_ns=start_ns, ticks_per_sec=ticks_per_sec) as w:
            for fid, flags, size, mtime, path in files:
                payload = struct.pack("<IIII", fid, flags, size, mtime) + path.encode() + b"\0"
                w.write_chunk(b"F", payload)
            for fid, line, calls_v, inc, exc in lines:
                payload = struct.pack("<IIIQQ", fid, line, calls_v, inc // 100, exc // 100)
                w.write_chunk(b"S", payload)
            if defs:
                if len(defs[0]) == 3:
                    d_payload = b"".join(
                        struct.pack("<II", sid, fl) + name.encode() + b"\0" for sid, fl, name in defs
                    )
                    w.write_chunk(b"D", d_payload)
                    c_payload = b"".join(
                        struct.pack("<IIIQQ", cs, ce, cnt, t, st) for cs, ce, cnt, t, st in calls
                    )
                    if c_payload:
                        w.write_chunk(b"C", c_payload)
                else:
                    d_payload = b"".join(
                        struct.pack("<IIII", sid, fid, sl, el) + name.encode() + b"\0" for sid, fid, sl, el, name in defs
                    )
                    w.write_chunk(b"D", d_payload)
                    c_payload = b"".join(
                        struct.pack("<IIIQQ", fid, line, sid, inc // 100, exc // 100)
                        for fid, line, sid, inc, exc in calls
                    )
                    if c_payload:
                        w.write_chunk(b"C", c_payload)
            w.close()

__all__ = ["write", "Writer"]
