#include <Python.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <unistd.h>
#include <assert.h>
#include "nytp_version.h"

const char *pynytprof_build_tag = __DATE__ " " __TIME__;

static void dbg_chunk(char tok, uint32_t len) {
    if (getenv("PYNTP_DEBUG"))
        fprintf(stderr, "[DBG] write chunk %c len=%u\n", tok, len);
}

static void write_chunk(FILE *fp, char token,
                        const void *payload, uint32_t len) {
    dbg_chunk(token, len);
    fputc(token, fp);
    fwrite(&len, 4, 1, fp);
    fwrite(payload, 1, len, fp);
}

static void put_u32le(unsigned char *p, uint32_t v) {
    p[0] = (unsigned char)(v & 0xFF);
    p[1] = (unsigned char)((v >> 8) & 0xFF);
    p[2] = (unsigned char)((v >> 16) & 0xFF);
    p[3] = (unsigned char)((v >> 24) & 0xFF);
}

static void put_u64le(unsigned char *p, uint64_t v) {
    put_u32le(p, (uint32_t)v);
    put_u32le(p + 4, (uint32_t)(v >> 32));
}


static const char *rfc_2822_time(void) {
    static char buf[64];
    time_t now = time(NULL);
    struct tm tm;
    gmtime_r(&now, &tm);
    strftime(buf, sizeof(buf), "%a, %d %b %Y %H:%M:%S +0000", &tm);
    return buf;
}

static const char *platform_name(void) {
    static char buf[64];
    struct utsname un;
    const char *os = "unknown";
    if (uname(&un) == 0)
        os = un.sysname;
    size_t i;
    for (i = 0; os[i] && i < sizeof(buf) - 1; i++)
        buf[i] = (char)tolower((unsigned char)os[i]);
    buf[i] = '\0';
    return buf;
}

static long basetime;

static void emit_header_ascii(FILE *fp) {
    fprintf(fp,
            "NYTProf %d %d\n"
            "#Perl profile database. Generated by Pynytprof on %s\n"
            ":basetime=%ld\n"
            ":application=-e\n"
            ":perl_version=%s\n"
            ":nv_size=%zu\n"
            ":clock_mod=cpu\n"
            ":ticks_per_sec=10000000\n"
            ":osname=%s\n"
            ":hz=%ld\n"
            "!subs=1\n"
            "!blocks=0\n"
            "!leave=1\n"
            "!expand=0\n"
            "!trace=0\n"
            "!use_db_sub=0\n"
            "!compress=0\n"
            "!clock=1\n"
            "!stmts=1\n"
            "!slowops=2\n"
            "!findcaller=0\n"
            "!forkdepth=-1\n"
            "!perldb=0\n"
            "!nameevals=1\n"
            "!nameanonsubs=1\n"
            "!calls=1\n"
            "!evals=0\n",
            NYTPROF_MAJOR, NYTPROF_MINOR, rfc_2822_time(), basetime,
            PY_VERSION, sizeof(double), platform_name(), sysconf(_SC_CLK_TCK));
}

static PyObject *pynytprof_write(PyObject *self, PyObject *args) {
    PyObject *path_obj, *files_obj, *defs_obj, *calls_obj, *lines_obj, *start_obj,
        *ticks_obj;
    if (!PyArg_ParseTuple(args, "OOOOOOO", &path_obj, &files_obj, &defs_obj,
                          &calls_obj, &lines_obj, &start_obj, &ticks_obj))
        return NULL;

    const char *path = PyUnicode_AsUTF8(path_obj);
    if (!path)
        return NULL;

    uint64_t start_ns = PyLong_AsUnsignedLongLong(start_obj);
    uint64_t ticks_per_sec = PyLong_AsUnsignedLongLong(ticks_obj);
    if (PyErr_Occurred())
        return NULL;

    PyObject *files = PySequence_Fast(files_obj, "files");
    PyObject *defs = PySequence_Fast(defs_obj, "defs");
    PyObject *calls = PySequence_Fast(calls_obj, "calls");
    PyObject *lines = PySequence_Fast(lines_obj, "lines");
    if (!files || !defs || !calls || !lines)
        return NULL;

    Py_ssize_t nfiles = PySequence_Fast_GET_SIZE(files);
    Py_ssize_t ndefs = PySequence_Fast_GET_SIZE(defs);
    Py_ssize_t ncalls = PySequence_Fast_GET_SIZE(calls);
    Py_ssize_t nlines = PySequence_Fast_GET_SIZE(lines);

    FILE *fp = fopen(path, "wb");
    if (!fp)
        return PyErr_SetFromErrnoWithFilename(PyExc_OSError, path);

    basetime = (long)(start_ns / 1000000000ULL);
    emit_header_ascii(fp);

    char abuf[128];
    int apos = 0;
    apos += sprintf(abuf + apos, "ticks_per_sec=%llu",
                    (unsigned long long)ticks_per_sec);
    abuf[apos++] = '\0';
    apos += sprintf(abuf + apos, "start_time=%llu",
                    (unsigned long long)start_ns);
    abuf[apos++] = '\0';
    size_t a_len = (size_t)apos;

    /* A chunk */
    write_chunk(fp, 'A', abuf, (uint32_t)a_len);

    /* F chunk */
    size_t f_len = 0;
    unsigned char *p;
    char *fdata = NULL;
    if (nfiles > 0) {
        for (Py_ssize_t i = 0; i < nfiles; i++) {
            PyObject *it = PySequence_Fast_GET_ITEM(files, i);
            const char *pstr = PyUnicode_AsUTF8(PyTuple_GET_ITEM(it, 4));
            f_len += 16 + strlen(pstr) + 1;
        }
        fdata = malloc(f_len);
        if (!fdata)
            goto mem_err;
        p = (unsigned char *)fdata;
        for (Py_ssize_t i = 0; i < nfiles; i++) {
            PyObject *it = PySequence_Fast_GET_ITEM(files, i);
            uint32_t fid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 0));
            uint32_t flags = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 1));
            uint32_t size = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 2));
            uint32_t mt = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 3));
            const char *pstr = PyUnicode_AsUTF8(PyTuple_GET_ITEM(it, 4));
            size_t l = strlen(pstr);
            put_u32le(p, fid);
            p += 4;
            put_u32le(p, flags);
            p += 4;
            put_u32le(p, size);
            p += 4;
            put_u32le(p, mt);
            p += 4;
            memcpy(p, pstr, l);
            p[l] = 0;
            p += l + 1;
        }
    }

    /* D chunk */
    size_t d_len = 0;
    for (Py_ssize_t i = 0; i < ndefs; i++) {
        PyObject *it = PySequence_Fast_GET_ITEM(defs, i);
        const char *name = PyUnicode_AsUTF8(PyTuple_GET_ITEM(it, 4));
        d_len += 16 + strlen(name) + 1;
    }
    char *ddata = malloc(d_len);
    if (!ddata) {
        if (fdata)
            free(fdata);
        goto mem_err;
    }
    p = (unsigned char *)ddata;
    for (Py_ssize_t i = 0; i < ndefs; i++) {
        PyObject *it = PySequence_Fast_GET_ITEM(defs, i);
        uint32_t sid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 0));
        uint32_t fid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 1));
        uint32_t sl = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 2));
        uint32_t el = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 3));
        const char *name = PyUnicode_AsUTF8(PyTuple_GET_ITEM(it, 4));
        size_t l = strlen(name);
        put_u32le(p, sid);
        p += 4;
        put_u32le(p, fid);
        p += 4;
        put_u32le(p, sl);
        p += 4;
        put_u32le(p, el);
        p += 4;
        memcpy(p, name, l);
        p[l] = 0;
        p += l + 1;
    }

    /* C chunk */
    size_t c_len = (size_t)ncalls * 28;
    char *cdata = malloc(c_len);
    if (!cdata) {
        if (fdata)
            free(fdata);
        free(ddata);
        goto mem_err;
    }
    p = (unsigned char *)cdata;
    for (Py_ssize_t i = 0; i < ncalls; i++) {
        PyObject *it = PySequence_Fast_GET_ITEM(calls, i);
        uint32_t fid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 0));
        uint32_t line = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 1));
        uint32_t sid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 2));
        uint64_t inc = PyLong_AsUnsignedLongLong(PyTuple_GET_ITEM(it, 3));
        uint64_t exc = PyLong_AsUnsignedLongLong(PyTuple_GET_ITEM(it, 4));
        inc /= 100;
        exc /= 100;
        put_u32le(p, fid);
        p += 4;
        put_u32le(p, line);
        p += 4;
        put_u32le(p, sid);
        p += 4;
        put_u64le(p, inc);
        p += 8;
        put_u64le(p, exc);
        p += 8;
    }

    /* S chunk */
    size_t s_len = (size_t)nlines * 28;
    char *sdata = malloc(s_len);
    if (!sdata) {
        if (fdata)
            free(fdata);
        free(ddata);
        free(cdata);
        goto mem_err;
    }
    p = (unsigned char *)sdata;
    for (Py_ssize_t i = 0; i < nlines; i++) {
        PyObject *it = PySequence_Fast_GET_ITEM(lines, i);
        uint32_t fid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 0));
        uint32_t line = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 1));
        uint32_t calls_v = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 2));
        uint64_t inc = PyLong_AsUnsignedLongLong(PyTuple_GET_ITEM(it, 3));
        uint64_t exc = PyLong_AsUnsignedLongLong(PyTuple_GET_ITEM(it, 4));
        inc /= 100;
        exc /= 100;
        put_u32le(p, fid);
        p += 4;
        put_u32le(p, line);
        p += 4;
        put_u32le(p, calls_v);
        p += 4;
        put_u64le(p, inc);
        p += 8;
        put_u64le(p, exc);
        p += 8;
    }

    if (nfiles > 0) {
        write_chunk(fp, 'F', fdata, (uint32_t)f_len);
    }
    write_chunk(fp, 'D', ddata, (uint32_t)d_len);
    write_chunk(fp, 'C', cdata, (uint32_t)c_len);
    write_chunk(fp, 'S', sdata, (uint32_t)s_len);
    {
        uint32_t zero = 0;
        fputc('E', fp);
        fwrite(&zero, 4, 1, fp);
    }

    if (fdata)
        free(fdata);
    free(ddata);
    free(cdata);
    free(sdata);
    fclose(fp);
    Py_RETURN_NONE;

mem_err:
    fclose(fp);
    return PyErr_NoMemory();
}

typedef struct {
    PyObject_HEAD
    FILE *fp;
} Writer;

static PyObject *
Writer_write_chunk(Writer *self, PyObject *args)
{
    const char *token_bytes;
    Py_ssize_t tlen;
    Py_buffer payload;
    if (!PyArg_ParseTuple(args, "y*y*", &token_bytes, &tlen, &payload))
        return NULL;
    if (tlen != 1) {
        PyErr_SetString(PyExc_ValueError, "token must be one byte");
        return NULL;
    }
    if (!self->fp) {
        PyErr_SetString(PyExc_ValueError, "writer not open");
        PyBuffer_Release(&payload);
        return NULL;
    }
    write_chunk(self->fp, token_bytes[0], payload.buf, (uint32_t)payload.len);
    PyBuffer_Release(&payload);
    Py_RETURN_NONE;
}

static PyMethodDef Writer_methods[] = {
    {"write_chunk", (PyCFunction)Writer_write_chunk, METH_VARARGS,
     PyDoc_STR("write_chunk(token: bytes, payload: bytes) -> None")},
    {NULL, NULL, 0, NULL}
};

static PyTypeObject WriterType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "_cwrite.Writer",
    .tp_basicsize = sizeof(Writer),
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = PyType_GenericNew,
    .tp_methods = Writer_methods,
};

static PyMethodDef Methods[] = {{"write", pynytprof_write, METH_VARARGS, "write"},
                                {NULL, NULL, 0, NULL}};

static struct PyModuleDef moddef = {PyModuleDef_HEAD_INIT, "_cwrite", NULL,
                                    -1, Methods};

PyMODINIT_FUNC PyInit__cwrite(void) {
    PyObject *mod = PyModule_Create(&moddef);
    if (!mod)
        return NULL;
    if (PyType_Ready(&WriterType) < 0)
        return NULL;
    Py_INCREF(&WriterType);
    PyModule_AddObject(mod, "Writer", (PyObject *)&WriterType);
    PyModule_AddStringConstant(mod, "__build__", pynytprof_build_tag);
    return mod;
}
