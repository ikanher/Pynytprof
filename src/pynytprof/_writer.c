#include <Python.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <unistd.h>
#include <assert.h>
#include "nytp_version.h"

#ifdef PYNYTPROF_BUILD_TAG
const char *pynytprof_build_tag = PYNYTPROF_BUILD_TAG;
#else
const char *pynytprof_build_tag = __DATE__ " " __TIME__;
#endif

static void dbg_chunk(char tok, uint32_t len) {
    if (getenv("PYNTP_DEBUG"))
        fprintf(stderr, "[DBG] write chunk %c len=%u\n", tok, len);
}

static void write_chunk(FILE *fp, char token,
                        const void *payload, uint32_t len) {
    dbg_chunk(token, len);
    fputc(token, fp);
    fwrite(&len, 4, 1, fp);
    fwrite(payload, 1, len, fp);
}

static void put_u32le(unsigned char *p, uint32_t v) {
    p[0] = (unsigned char)(v & 0xFF);
    p[1] = (unsigned char)((v >> 8) & 0xFF);
    p[2] = (unsigned char)((v >> 16) & 0xFF);
    p[3] = (unsigned char)((v >> 24) & 0xFF);
}

static void put_u64le(unsigned char *p, uint64_t v) {
    put_u32le(p, (uint32_t)v);
    put_u32le(p + 4, (uint32_t)(v >> 32));
}


static const char *rfc_2822_time(void) {
    static char buf[64];
    time_t now = time(NULL);
    struct tm tm;
    gmtime_r(&now, &tm);
    strftime(buf, sizeof(buf), "%a, %d %b %Y %H:%M:%S +0000", &tm);
    return buf;
}

static const char *platform_name(void) {
    static char buf[64];
    struct utsname un;
    const char *os = "unknown";
    if (uname(&un) == 0)
        os = un.sysname;
    size_t i;
    for (i = 0; os[i] && i < sizeof(buf) - 1; i++)
        buf[i] = (char)tolower((unsigned char)os[i]);
    buf[i] = '\0';
    return buf;
}

static long basetime;

static unsigned emit_banner(FILE *fp) {
    char buf[1024];
    int len = snprintf(buf, sizeof(buf),
                       "NYTProf %d %d\n"
                       "#Perl profile database. Generated by Pynytprof on %s\n"
                       ":basetime=%ld\n"
                       ":application=-e\n"
                       ":perl_version=%s\n"
                       ":nv_size=%zu\n"
                       ":clock_mod=cpu\n"
                       ":ticks_per_sec=10000000\n"
                       ":osname=%s\n"
                       ":hz=%ld\n"
                       "!subs=1\n"
                       "!blocks=0\n"
                       "!leave=1\n"
                       "!expand=0\n"
                       "!trace=0\n"
                       "!use_db_sub=0\n"
                       "!compress=0\n"
                       "!clock=1\n"
                       "!stmts=1\n"
                       "!slowops=2\n"
                       "!findcaller=0\n"
                       "!forkdepth=-1\n"
                       "!perldb=0\n"
                       "!nameevals=1\n"
                       "!nameanonsubs=1\n"
                       "!calls=1\n"
                       "!evals=0\n",
                       NYTPROF_MAJOR, NYTPROF_MINOR, rfc_2822_time(), basetime,
                       PY_VERSION, sizeof(double), platform_name(), sysconf(_SC_CLK_TCK));
    unsigned header_size = (unsigned)len + (unsigned)strlen(":header_size=00000\n") + 1;
    fprintf(fp, "%s:header_size=%05u\n\n", buf, header_size);
    return header_size;
}

static void put_double_le(unsigned char *p, double v) {
    union {
        double d;
        unsigned char b[8];
    } u;
    u.d = v;
    memcpy(p, u.b, 8);
}

static void store_le32(FILE *fp, uint32_t v) {
    unsigned char b[4];
    put_u32le(b, v);
    fwrite(b, 1, 4, fp);
}

static void store_le_double(FILE *fp, double v) {
    unsigned char b[8];
    put_double_le(b, v);
    fwrite(b, 1, 8, fp);
}

static void emit_header(FILE *fp) {
    unsigned hdr_size = emit_banner(fp);
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    double t = (double)ts.tv_sec + (double)ts.tv_nsec / 1e9;
    fputc('P', fp);
    store_le32(fp, (uint32_t)getpid());
    store_le32(fp, (uint32_t)getppid());
    store_le_double(fp, t);
    if (getenv("PYNYTPROF_DEBUG")) {
        fprintf(stderr, "DEBUG: wrote raw P record (17 B)\n");
        fprintf(stderr, "DEBUG: header_size=%d first_token=P\n", hdr_size);
    }

}

static PyObject *pynytprof_write(PyObject *self, PyObject *args) {
    PyObject *path_obj, *files_obj, *defs_obj, *calls_obj, *lines_obj, *start_obj,
        *ticks_obj;
    if (!PyArg_ParseTuple(args, "OOOOOOO", &path_obj, &files_obj, &defs_obj,
                          &calls_obj, &lines_obj, &start_obj, &ticks_obj))
        return NULL;

    const char *path = PyUnicode_AsUTF8(path_obj);
    if (!path)
        return NULL;

    uint64_t start_ns = PyLong_AsUnsignedLongLong(start_obj);
    uint64_t ticks_per_sec = PyLong_AsUnsignedLongLong(ticks_obj);
    if (PyErr_Occurred())
        return NULL;

    PyObject *files = PySequence_Fast(files_obj, "files");
    PyObject *defs = PySequence_Fast(defs_obj, "defs");
    PyObject *calls = PySequence_Fast(calls_obj, "calls");
    PyObject *lines = PySequence_Fast(lines_obj, "lines");
    if (!files || !defs || !calls || !lines)
        return NULL;

    Py_ssize_t nfiles = PySequence_Fast_GET_SIZE(files);
    Py_ssize_t ndefs = PySequence_Fast_GET_SIZE(defs);
    Py_ssize_t ncalls = PySequence_Fast_GET_SIZE(calls);
    Py_ssize_t nlines = PySequence_Fast_GET_SIZE(lines);

    FILE *fp = fopen(path, "wb");
    if (!fp)
        return PyErr_SetFromErrnoWithFilename(PyExc_OSError, path);

    basetime = (long)(start_ns / 1000000000ULL);
    emit_header(fp);


    unsigned char *p;

    /* D chunk */
    size_t d_len = 0;
    for (Py_ssize_t i = 0; i < ndefs; i++) {
        PyObject *it = PySequence_Fast_GET_ITEM(defs, i);
        const char *name = PyUnicode_AsUTF8(PyTuple_GET_ITEM(it, 4));
        d_len += 16 + strlen(name) + 1;
    }
    char *ddata = malloc(d_len);
    if (!ddata) {
        goto mem_err;
    }
    p = (unsigned char *)ddata;
    for (Py_ssize_t i = 0; i < ndefs; i++) {
        PyObject *it = PySequence_Fast_GET_ITEM(defs, i);
        uint32_t sid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 0));
        uint32_t fid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 1));
        uint32_t sl = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 2));
        uint32_t el = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 3));
        const char *name = PyUnicode_AsUTF8(PyTuple_GET_ITEM(it, 4));
        size_t l = strlen(name);
        put_u32le(p, sid);
        p += 4;
        put_u32le(p, fid);
        p += 4;
        put_u32le(p, sl);
        p += 4;
        put_u32le(p, el);
        p += 4;
        memcpy(p, name, l);
        p[l] = 0;
        p += l + 1;
    }

    /* C chunk */
    size_t c_len = (size_t)ncalls * 28;
    char *cdata = malloc(c_len);
    if (!cdata) {
        free(ddata);
        goto mem_err;
    }
    p = (unsigned char *)cdata;
    for (Py_ssize_t i = 0; i < ncalls; i++) {
        PyObject *it = PySequence_Fast_GET_ITEM(calls, i);
        uint32_t fid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 0));
        uint32_t line = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 1));
        uint32_t sid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 2));
        uint64_t inc = PyLong_AsUnsignedLongLong(PyTuple_GET_ITEM(it, 3));
        uint64_t exc = PyLong_AsUnsignedLongLong(PyTuple_GET_ITEM(it, 4));
        inc /= 100;
        exc /= 100;
        put_u32le(p, fid);
        p += 4;
        put_u32le(p, line);
        p += 4;
        put_u32le(p, sid);
        p += 4;
        put_u64le(p, inc);
        p += 8;
        put_u64le(p, exc);
        p += 8;
    }

    /* S chunk */
    size_t s_len = (size_t)nlines * 28;
    char *sdata = malloc(s_len);
    if (!sdata) {
        free(ddata);
        free(cdata);
        goto mem_err;
    }
    p = (unsigned char *)sdata;
    for (Py_ssize_t i = 0; i < nlines; i++) {
        PyObject *it = PySequence_Fast_GET_ITEM(lines, i);
        uint32_t fid = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 0));
        uint32_t line = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 1));
        uint32_t calls_v = (uint32_t)PyLong_AsUnsignedLong(PyTuple_GET_ITEM(it, 2));
        uint64_t inc = PyLong_AsUnsignedLongLong(PyTuple_GET_ITEM(it, 3));
        uint64_t exc = PyLong_AsUnsignedLongLong(PyTuple_GET_ITEM(it, 4));
        inc /= 100;
        exc /= 100;
        put_u32le(p, fid);
        p += 4;
        put_u32le(p, line);
        p += 4;
        put_u32le(p, calls_v);
        p += 4;
        put_u64le(p, inc);
        p += 8;
        put_u64le(p, exc);
        p += 8;
    }

    write_chunk(fp, 'D', ddata, (uint32_t)d_len);
    write_chunk(fp, 'C', cdata, (uint32_t)c_len);
    write_chunk(fp, 'S', sdata, (uint32_t)s_len);
    write_chunk(fp, 'E', NULL, 0);

    free(ddata);
    free(cdata);
    free(sdata);
    fclose(fp);
    Py_RETURN_NONE;

mem_err:
    fclose(fp);
    return PyErr_NoMemory();
}

typedef struct {
    PyObject_HEAD
    FILE *fp;
} Writer;

static PyObject *
Writer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"path", "start_ns", "ticks_per_sec", "tracer", NULL};
    const char *path;
    unsigned long long start_ns = 0;
    unsigned long long ticks = 10000000ULL;
    PyObject *tracer = NULL;
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "s|KKO", kwlist, &path,
                                     &start_ns, &ticks, &tracer))
        return NULL;

    Writer *self = (Writer *)type->tp_alloc(type, 0);
    if (!self)
        return NULL;
    self->fp = fopen(path, "wb");
    if (!self->fp) {
        Py_DECREF(self);
        return PyErr_SetFromErrnoWithFilename(PyExc_OSError, path);
    }
    (void)ticks; /* unused */
    basetime = (long)(start_ns / 1000000000ULL);
    emit_header(self->fp);
    return (PyObject *)self;
}

static PyObject *
Writer_write_chunk(Writer *self, PyObject *args)
{
    Py_buffer tokbuf, paybuf;
    if (!PyArg_ParseTuple(args, "y*y*", &tokbuf, &paybuf))
        return NULL;
    if (tokbuf.len != 1) {
        PyErr_SetString(PyExc_ValueError, "token must be exactly one byte");
        PyBuffer_Release(&tokbuf);
        PyBuffer_Release(&paybuf);
        return NULL;
    }
    /* emit */
    write_chunk(self->fp,
                ((const unsigned char *)tokbuf.buf)[0],
                paybuf.buf,
                (uint32_t)paybuf.len);
    PyBuffer_Release(&tokbuf);
    PyBuffer_Release(&paybuf);
    Py_RETURN_NONE;
}

static PyObject *
Writer_close(Writer *self, PyObject *Py_UNUSED(args))
{
    if (self->fp) {
        write_chunk(self->fp, 'E', NULL, 0);
        fclose(self->fp);
        self->fp = NULL;
    }
    Py_RETURN_NONE;
}

static PyObject *
Writer_enter(Writer *self, PyObject *Py_UNUSED(args))
{
    Py_INCREF(self);
    return (PyObject *)self;
}

static PyObject *
Writer_exit(Writer *self, PyObject *args)
{
    Writer_close(self, NULL);
    Py_RETURN_NONE;
}

static PyMethodDef Writer_methods[] = {
    {"write_chunk", (PyCFunction)Writer_write_chunk, METH_VARARGS,
     PyDoc_STR("write_chunk(token: bytes, payload: bytes) -> None")},
    {"close", (PyCFunction)Writer_close, METH_NOARGS, PyDoc_STR("close() -> None")},
    {"__enter__", (PyCFunction)Writer_enter, METH_NOARGS, NULL},
    {"__exit__", (PyCFunction)Writer_exit, METH_VARARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static PyTypeObject WriterType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "_cwrite.Writer",
    .tp_basicsize = sizeof(Writer),
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = Writer_new,
    .tp_methods = Writer_methods,
};

static PyMethodDef Methods[] = {{"write", pynytprof_write, METH_VARARGS, "write"},
                                {NULL, NULL, 0, NULL}};

static struct PyModuleDef moddef = {PyModuleDef_HEAD_INIT, "_cwrite", NULL,
                                    -1, Methods};

PyMODINIT_FUNC PyInit__cwrite(void) {
    PyObject *mod = PyModule_Create(&moddef);
    if (!mod)
        return NULL;
    if (PyType_Ready(&WriterType) < 0)
        return NULL;
    Py_INCREF(&WriterType);
    PyModule_AddObject(mod, "Writer", (PyObject *)&WriterType);
    PyModule_AddStringConstant(mod, "__build__", pynytprof_build_tag);
    return mod;
}
