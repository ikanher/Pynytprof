from __future__ import annotations

import os
import sys
import time
import struct
import datetime
from pathlib import Path
from email.utils import format_datetime
from importlib import resources
import re

from .encoding import le32, ledouble, encode_u32
from .nytprof_tags import NYTP_TAG_PID_END
from ._debug import DBG, log
from .token_writer import TokenWriter

try:
    _version_text = resources.files(__package__).joinpath("nytp_version.h").read_text()
except AttributeError:  # pragma: no cover
    _version_text = resources.read_text(__package__, "nytp_version.h")
_major_match = re.search(r"NYTPROF_MAJOR\s+(\d+)", _version_text)
_minor_match = re.search(r"NYTPROF_MINOR\s+(\d+)", _version_text)
NYTPROF_MAJOR = int(_major_match.group(1)) if _major_match else 5
NYTPROF_MINOR = int(_minor_match.group(1)) if _minor_match else 0


def _make_ascii_header(static: str) -> bytes:
    return (static.rstrip("\n") + "\n").encode()


class Writer:
    def __init__(
        self,
        path: str | None = None,
        start_ns: int | None = None,
        ticks_per_sec: int = 10_000_000,
        tracer=None,
        script_path: str | None = None,
        fp=None,
    ) -> None:
        if path is not None and not isinstance(path, (str, os.PathLike)):
            fp = path
            path = None
        self._path = Path(path) if path is not None else None
        self._fh = fp
        self.ticks_per_sec = ticks_per_sec
        self._start_ns = time.time_ns() if start_ns is None else start_ns
        self.tracer = tracer
        self.script_path = str(Path(script_path or sys.argv[0]).resolve())
        self.nv_size = struct.calcsize("d")
        self._tok = TokenWriter()
        self._file_ids: dict[str, int] = {}
        self._emitted_fids: set[int] = set()
        self._next_fid = 1
        self._register_file(self.script_path)
        self._offset = 0
        if DBG.active:
            self._buffer = bytearray()
        else:
            self._buffer = bytearray()

    # file registration -------------------------------------------------
    def _register_file(self, path: str) -> int:
        fid = self._file_ids.get(path)
        if fid is None:
            fid = self._next_fid
            self._file_ids[path] = fid
            self._next_fid += 1
        return fid

    # low level writers -------------------------------------------------
    def _write_raw(self, data: bytes) -> None:
        assert self._fh is not None
        self._fh.write(data)
        self._offset += len(data)
        if DBG.active:
            self._buffer.extend(data)

    def _write_raw_P(self, pid: int | None = None, ppid: int | None = None, tstamp: float | None = None) -> None:
        if pid is None:
            pid = os.getpid()
        if ppid is None:
            ppid = os.getppid()
        if tstamp is None:
            tstamp = time.time()
        payload = self._tok.write_p_record(pid, ppid, tstamp)
        self._write_raw(payload)

    def _emit_new_fid(self, fid: int, path: str) -> None:
        if fid in self._emitted_fids:
            return
        try:
            st = os.stat(path)
        except OSError:
            st = os.stat_result((0,) * 10)
        payload = self._tok.write_new_fid(
            fid,
            0,
            0,
            0x10,
            int(st.st_size),
            int(st.st_mtime),
            path,
        )
        self._write_raw(payload)
        self._emitted_fids.add(fid)

    def write_time_line(self, fid: int, line: int, elapsed: int, overflow: int) -> None:
        payload = self._tok.write_time_line(fid, line, elapsed, overflow)
        self._write_raw(payload)

    # header ------------------------------------------------------------
    def _write_header(self) -> None:
        timestamp = format_datetime(datetime.datetime.now(datetime.timezone.utc))
        basetime = int(self._start_ns // 1_000_000_000)
        script = os.path.basename(self.script_path)
        lines = [
            f"NYTProf {NYTPROF_MAJOR} {NYTPROF_MINOR}".encode("ascii"),
            f"#Perl profile database. Generated by Pynytprof on {timestamp}".encode("ascii"),
            f":basetime={basetime}".encode("ascii"),
            f":application={script}".encode("ascii"),
            f":perl_version={sys.version.split()[0]}".encode("ascii"),
            f":nv_size={self.nv_size}".encode("ascii"),
            b":xs_version=6.11",
            b":PL_perldb=0",
            b":clock_id=1",
            b":ticks_per_sec=10000000",
            b"!usecputime=0",
            b"!subs=1",
            b"!blocks=0",
            b"!leave=1",
            b"!expand=0",
            b"!trace=0",
            b"!use_db_sub=0",
            b"!compress=0",
            b"!clock=1",
            b"!stmts=1",
            b"!slowops=2",
            b"!findcaller=0",
            b"!forkdepth=-1",
            b"!perldb=0",
            b"!nameevals=1",
            b"!nameanonsubs=1",
            b"!calls=1",
            b"!evals=0",
        ]
        banner = b"\n".join(lines).rstrip(b"\n") + b"\n"
        self._write_raw(banner)
        self._write_raw_P()
        # emit NEW_FID for script file immediately
        fid = self._file_ids[self.script_path]
        self._emit_new_fid(fid, self.script_path)

    # public API --------------------------------------------------------
    def start_profile(self) -> None:
        if self._fh is None:
            if self._path is None:
                raise ValueError("no output path specified")
            self._fh = open(self._path, "wb")
        if self._offset == 0:
            self._write_header()

    def end_profile(self) -> None:
        self.close()

    def __enter__(self):
        if self._fh is None:
            if self._path is None:
                raise ValueError("no output path specified")
            self._fh = open(self._path, "wb")
        self._write_header()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()

    def close(self) -> None:
        if not self._fh:
            return
        # nothing else for now
        payload = bytes([NYTP_TAG_PID_END]) + encode_u32(os.getpid()) + ledouble(time.time())
        self._write_raw(payload)
        self._fh.close()
        self._fh = None

    finalize = close

    # compatibility with old writer API
    def write_chunk(self, token: bytes, payload: bytes) -> None:  # pragma: no cover - legacy
        if token == b"S":
            # payload layout: varints fid,line,calls,inc,exc repeated
            # not currently implemented
            return
        if token == b"F":
            return
        if token == b"D" or token == b"C":
            return


def write(out_path: str, *args, start_ns: int = 0, ticks_per_sec: int = 10_000_000, **kwargs) -> None:
    with Writer(out_path, start_ns=start_ns, ticks_per_sec=ticks_per_sec) as w:
        w.start_profile()
        w.end_profile()


__all__ = ["Writer", "write", "_make_ascii_header"]
