# Simple pure-Python NYTProf writer fallback
from __future__ import annotations

from pathlib import Path
import struct
import time
import os
import sys
import platform
import datetime
from email.utils import format_datetime
from importlib import resources
import re

try:  # Python 3.9+
    _version_text = resources.files(__package__).joinpath("nytp_version.h").read_text()
except AttributeError:  # pragma: no cover - fallback for Python < 3.9
    _version_text = resources.read_text(__package__, "nytp_version.h")
_major_match = re.search(r"NYTPROF_MAJOR\s+(\d+)", _version_text)
_minor_match = re.search(r"NYTPROF_MINOR\s+(\d+)", _version_text)
NYTPROF_MAJOR = int(_major_match.group(1)) if _major_match else 5
NYTPROF_MINOR = int(_minor_match.group(1)) if _minor_match else 0


def _make_ascii_header(start_ns: int) -> bytes:
    now = format_datetime(datetime.datetime.now(datetime.timezone.utc))
    try:
        hz = os.sysconf("SC_CLK_TCK")  # type: ignore[arg-type]
    except (AttributeError, ValueError, OSError):
        hz = 100
    lines = [
        f"NYTProf {NYTPROF_MAJOR} {NYTPROF_MINOR}",
        f"#Perl profile database. Generated by Pynytprof on {now}",
        f":basetime={int(start_ns // 1_000_000_000)}",
        ":application=-e",
        f":perl_version={sys.version.split()[0]}",
        f":nv_size={struct.calcsize('d')}",
        ":clock_mod=cpu",
        ":ticks_per_sec=10000000",
        f":osname={platform.system().lower()}",
        f":hz={hz}",
    ]
    hdr = ("\n".join(lines) + "\n").encode()
    assert b"\0" not in hdr
    return hdr


def _chunk(tok: bytes, payload: bytes) -> bytes:
    return tok + struct.pack("<I", len(payload)) + payload


class Writer:
    def __init__(self, path: str, start_ns: int | None = None):
        self._path = Path(path)
        self._fh = None
        self._start_ns = time.time_ns() if start_ns is None else start_ns

    def __enter__(self):
        self._fh = open(self._path, "wb")
        self._write_ascii_header()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()

    def close(self) -> None:
        if self._fh:
            self._write_chunk(b"E", b"")
            self._fh.close()
        self._fh = None

    def _write_ascii_header(self) -> None:
        now = format_datetime(datetime.datetime.now(datetime.timezone.utc))
        try:
            hz = os.sysconf("SC_CLK_TCK")  # type: ignore[arg-type]
        except (AttributeError, ValueError, OSError):
            hz = 100
        lines = [
            f"NYTProf {NYTPROF_MAJOR} {NYTPROF_MINOR}",
            f"#Perl profile database. Generated by Pynytprof on {now}",
            f":basetime={int(self._start_ns // 1_000_000_000)}",
            ":application=-e",
            f":perl_version={sys.version.split()[0]}",
            f":nv_size={struct.calcsize('d')}",
            ":clock_mod=cpu",
            ":ticks_per_sec=10000000",
            f":osname={platform.system().lower()}",
            f":hz={hz}",
        ]
        hdr = ("\n".join(lines) + "\n").encode()
        assert b"\0" not in hdr
        self._fh.write(hdr)

    def _write_chunk(self, tag: bytes, payload: bytes) -> None:
        self._fh.write(tag)
        self._fh.write(struct.pack("<I", len(payload)))
        if payload:
            self._fh.write(payload)


def write(
    out_path: str,
    files: list[tuple[int, int, int, int, str]],
    defs: list[tuple[int, int, int, int, str]],
    calls: list[tuple[int, int, int, int, int]],
    lines: list[tuple[int, int, int, int, int]],
    start_ns: int,
    ticks_per_sec: int,
) -> None:
    """Write NYTProf file purely in Python."""
    path = Path(out_path)
    with path.open("wb") as f:
        f.write(_make_ascii_header(start_ns))
        a_payload = f"ticks_per_sec={ticks_per_sec}\0start_time={start_ns}\0".encode()
        f.write(_chunk(b"A", a_payload))
        f_payload = b"".join(
            struct.pack("<IIII", fid, flags, size, mtime) + p.encode() + b"\0"
            for fid, flags, size, mtime, p in files
        )
        f.write(_chunk(b"F", f_payload))
        d_payload = b"".join(
            struct.pack("<IIII", sid, fid, sl, el) + name.encode() + b"\0"
            for sid, fid, sl, el, name in defs
        )
        f.write(_chunk(b"D", d_payload))
        c_payload = b"".join(
            struct.pack("<IIIQQ", fid, line, sid, inc // 100, exc // 100)
            for fid, line, sid, inc, exc in calls
        )
        f.write(_chunk(b"C", c_payload))
        s_payload = b"".join(
            struct.pack("<IIIQQ", fid, line, calls_v, inc // 100, exc // 100)
            for fid, line, calls_v, inc, exc in lines
        )
        f.write(_chunk(b"S", s_payload))
        f.write(_chunk(b"E", b""))
