from __future__ import annotations

from pathlib import Path
import struct
import time
import os
import sys
import platform
import datetime
from email.utils import format_datetime
from importlib import resources
import re
import subprocess
import ctypes

try:  # Python 3.9+
    _version_text = resources.files(__package__).joinpath("nytp_version.h").read_text()
except AttributeError:  # pragma: no cover - fallback for Python < 3.9
    _version_text = resources.read_text(__package__, "nytp_version.h")

_major_match = re.search(r"NYTPROF_MAJOR\s+(\d+)", _version_text)
_minor_match = re.search(r"NYTPROF_MINOR\s+(\d+)", _version_text)
NYTPROF_MAJOR = int(_major_match.group(1)) if _major_match else 5
NYTPROF_MINOR = int(_minor_match.group(1)) if _minor_match else 0


def _perl_nv_size() -> int:
    try:
        out = subprocess.check_output(
            ["perl", "-MConfig", "-e", "print $Config{nvsize}"],
            text=True,
        )
        return int(out.strip() or 8)
    except Exception:
        return 8

def _make_ascii_header(start_ns: int, nv_size: int) -> bytes:
    now = format_datetime(datetime.datetime.now(datetime.timezone.utc)).lower()
    try:
        hz = os.sysconf("SC_CLK_TCK")  # type: ignore[arg-type]
    except (AttributeError, ValueError, OSError):
        hz = 100
    lines = [
        f"NYTProf {NYTPROF_MAJOR} {NYTPROF_MINOR}",
        f"#Perl profile database. Generated by Pynytprof on {now}",
        f":basetime={int(start_ns // 1_000_000_000)}",
        ":application=-e",
        f":perl_version={sys.version.split()[0]}",
        f":nv_size={nv_size}",
        ":clock_mod=cpu",
        ":ticks_per_sec=10000000",
        f":osname={platform.system().lower()}",
        f":hz={hz}",
        "!subs=1",
        "!blocks=0",
        "!leave=1",
        "!expand=0",
        "!trace=0",
        "!use_db_sub=0",
        "!compress=0",
        "!clock=1",
        "!stmts=1",
        "!slowops=2",
        "!findcaller=0",
        "!forkdepth=-1",
        "!perldb=0",
        "!nameevals=1",
        "!nameanonsubs=1",
        "!calls=1",
        "!evals=0",
    ]
    hdr = ("\n".join(lines) + "\n").encode()
    assert b"\0" not in hdr
    return hdr


def _chunk(tok: bytes, payload: bytes) -> bytes:
    return tok[:1] + len(payload).to_bytes(4, "little") + payload


class Writer:
    def __init__(
        self,
        path: str | None = None,
        start_ns: int | None = None,
        ticks_per_sec: int = 10_000_000,
        tracer=None,
        script_path: str | None = None,
        fp=None,
    ) -> None:
        self._path = Path(path) if path is not None else None
        self._fh = fp
        self.start_time = time.time_ns() if start_ns is None else start_ns
        self.ticks_per_sec = ticks_per_sec
        self._start_ns = self.start_time
        self.tracer = tracer
        self.writer = self
        self.script_path = str(Path(script_path or sys.argv[0]).resolve())
        self._nv_size = _perl_nv_size()
        self._line_hits: dict[tuple[int, int], tuple[int, int, int]] = {}
        self._stmt_records: list[tuple[int, int, int]] = []
        self._payloads: dict[bytes, bytearray] = {
            b"S": bytearray(),
            b"D": bytearray(),
            b"C": bytearray(),
        }
        if os.getenv("PYNYTPROF_DEBUG"):
            print("DEBUG: Writer initialized with empty buffers", file=sys.stderr)

    def _write_raw_P(self, pid: int, ppid: int) -> None:
        if self._fh is None:
            raise ValueError("writer not opened")
        tv = time.time()
        if self._nv_size == 8:
            nv_bytes = struct.pack("<d", tv)
        elif self._nv_size == 16:
            nv = ctypes.c_longdouble(tv)
            nv_bytes = ctypes.string_at(ctypes.byref(nv), 16)
        else:
            raise ValueError(f"Unsupported NV size {self._nv_size}")
        payload = struct.pack("<II", pid, ppid) + nv_bytes
        self._fh.write(b"P")
        self._fh.write(struct.pack("<I", len(payload)))
        self._fh.write(payload)

    def _write_header(self) -> None:
        banner = _make_ascii_header(self._start_ns, self._nv_size)
        assert banner.endswith(b"\n")
        if os.getenv("PYNYTPROF_DEBUG"):
            last_line = banner.rstrip(b"\n").split(b"\n")[-1] + b"\n"
            print(f"DEBUG: writing banner len={len(banner)}", file=sys.stderr)
            print(f"DEBUG: banner_end={last_line!r}", file=sys.stderr)
        self._fh.write(banner)

        pid = os.getpid()
        ppid = os.getppid()
        start_time_s = time.time()
        if self._nv_size == 8:
            nv_bytes = struct.pack("<d", start_time_s)
        elif self._nv_size == 16:
            nv = ctypes.c_longdouble(start_time_s)
            nv_bytes = ctypes.string_at(ctypes.byref(nv), 16)
        else:
            raise ValueError(f"Unsupported NV size {self._nv_size}")
        payload = struct.pack("<II", pid, ppid) + nv_bytes
        banner_len = len(banner)
        self.header_size = banner_len + 1 + 4 + len(payload)
        if os.getenv("PYNYTPROF_DEBUG"):
            p_offset = banner_len
            s_offset = p_offset + 1 + 4 + len(payload)
            print(f"DEBUG: P-payload raw={payload.hex()}", file=sys.stderr)
            print(
                f"DEBUG: P-offset=0x{p_offset:x} S-offset expected=0x{s_offset:x}",
                file=sys.stderr,
            )
        self._write_raw_P(pid, ppid)
        if os.getenv("PYNYTPROF_DEBUG"):
            print(
                f"DEBUG: wrote raw P record ({len(payload)+5} B) pid={pid} ppid={ppid}",
                file=sys.stderr,
            )
            print(
                f"DEBUG: header_size={self.header_size} first_token=P",
                file=sys.stderr,
            )

    def _write_chunk(self, tag: bytes, payload: bytes) -> None:
        payload = payload.replace(b"\n", b"\x01")
        length = len(payload)
        while b"\n" in length.to_bytes(4, "little"):
            payload += b"\x00"
            length = len(payload)
        if os.getenv("PYNYTPROF_DEBUG"):
            offset = self._fh.tell()
            from hashlib import sha256

            digest = sha256(payload).hexdigest() if payload else ""
            first16 = payload[:16].hex()
            last16 = payload[-16:].hex() if payload else ""
            print(
                f"DEBUG: write tag={tag.decode()} len={length}",
                file=sys.stderr,
            )
            print(
                f"       offset=0x{offset:x}",
                file=sys.stderr,
            )
            print(
                f"       sha256={digest}",
                file=sys.stderr,
            )
            if payload:
                print(
                    f"       first16={first16} last16={last16}",
                    file=sys.stderr,
                )
        self._fh.write(tag + length.to_bytes(4, "little") + payload)

    def record_line(self, fid: int, line: int, calls: int, inc: int, exc: int) -> None:
        self._line_hits[(fid, line)] = (calls, inc, exc)

    def write_chunk(self, token: bytes, payload: bytes) -> None:
        tag = token[:1]
        if tag in self._payloads:
            if tag == b"D" and not payload:
                return
            self._payloads[tag].extend(payload)
        elif tag == b"E":
            pass

    def __enter__(self):
        if self._fh is None:
            if self._path is None:
                raise ValueError("no output path specified")
            self._fh = open(self._path, "wb")
        self._write_header()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.finalize()

    def close(self) -> None:
        if not self._fh:
            return

        if self.tracer is not None:

            def ns2ticks(ns: int) -> int:
                return ns // 100

            for line, calls in self.tracer._line_hits.items():
                self._line_hits[(0, line)] = (
                    calls,
                    ns2ticks(self.tracer._line_time_ns[line]),
                    ns2ticks(self.tracer._exc_time_ns.get(line, 0)),
                )

        recs = []
        for (fid, line), (calls, inc, exc) in self._line_hits.items():
            recs.append(struct.pack("<IIIQQ", fid, line, calls, inc, exc))
        if recs:
            self._payloads[b"S"].extend(b"".join(recs))

        if self._stmt_records and not self._payloads[b"D"]:
            buf = bytearray()
            for fid, line, dur in self._stmt_records:
                buf += struct.pack("<BIIQ", 1, fid, line, dur)
            buf.append(0)
            self._payloads[b"D"] = buf
        elif not self._payloads[b"D"]:
            self._payloads[b"D"] = bytearray()

        if os.getenv("PYNYTPROF_DEBUG"):
            summary = {t.decode(): len(self._payloads.get(t, b"")) for t in [b"S", b"D", b"C"]}
            summary["E"] = 0
            print(f"FINAL CHUNKS: {summary}", file=sys.stderr)

        for tag in [b"S", b"D", b"C", b"E"]:
            payload = bytes(self._payloads.get(tag, b"")) if tag != b"E" else b""
            self._write_chunk(tag, payload)
        self._fh.close()
        self._fh = None

    def finalize(self) -> None:
        self.close()


def write(out_path: str, files, defs, calls, lines, start_ns: int, ticks_per_sec: int) -> None:
    path = Path(out_path)
    nv_size = _perl_nv_size()
    with path.open("wb") as f:
        banner = _make_ascii_header(start_ns, nv_size)
        f.write(banner)

        pid = os.getpid()
        ppid = os.getppid()
        ts = time.time()
        if nv_size == 8:
            nv_bytes = struct.pack("<d", ts)
        elif nv_size == 16:
            nv = ctypes.c_longdouble(ts)
            nv_bytes = ctypes.string_at(ctypes.byref(nv), 16)
        else:
            raise ValueError(f"Unsupported NV size {nv_size}")
        payload = struct.pack("<II", pid, ppid) + nv_bytes
        f.write(b"P")
        f.write(struct.pack("<I", len(payload)))
        f.write(payload)

        s_payload = b"".join(
            struct.pack("<IIIQQ", fid, line, calls_v, inc // 100, exc // 100)
            for fid, line, calls_v, inc, exc in lines
        )
        f.write(_chunk(b"S", s_payload))

        d_payload = b""
        c_payload = b""
        if defs:
            if len(defs[0]) == 3:
                d_payload = b"".join(
                    struct.pack("<II", sid, flags) + name.encode() + b"\0"
                    for sid, flags, name in defs
                )
                c_payload = b"".join(
                    struct.pack("<IIIQQ", cs, ce, cnt, t, st) for cs, ce, cnt, t, st in calls
                )
            else:
                d_payload = b"".join(
                    struct.pack("<IIII", sid, fid, sl, el) + name.encode() + b"\0"
                    for sid, fid, sl, el, name in defs
                )
                c_payload = b"".join(
                    struct.pack("<IIIQQ", fid, line, sid, inc // 100, exc // 100)
                    for fid, line, sid, inc, exc in calls
                )
        f.write(_chunk(b"D", d_payload))
        f.write(_chunk(b"C", c_payload))
        f.write(_chunk(b"E", b""))
