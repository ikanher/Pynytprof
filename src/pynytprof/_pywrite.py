# Simple pure-Python NYTProf writer fallback
from __future__ import annotations

from pathlib import Path
import struct
import time
import os
import sys
import platform
import datetime
from email.utils import format_datetime
from importlib import resources
import re
import hashlib

try:  # Python 3.9+
    _version_text = resources.files(__package__).joinpath("nytp_version.h").read_text()
except AttributeError:  # pragma: no cover - fallback for Python < 3.9
    _version_text = resources.read_text(__package__, "nytp_version.h")
_major_match = re.search(r"NYTPROF_MAJOR\s+(\d+)", _version_text)
_minor_match = re.search(r"NYTPROF_MINOR\s+(\d+)", _version_text)
NYTPROF_MAJOR = int(_major_match.group(1)) if _major_match else 5
NYTPROF_MINOR = int(_minor_match.group(1)) if _minor_match else 0


def _make_ascii_header(start_ns: int) -> bytes:
    now = format_datetime(datetime.datetime.now(datetime.timezone.utc)).lower()
    try:
        hz = os.sysconf("SC_CLK_TCK")  # type: ignore[arg-type]
    except (AttributeError, ValueError, OSError):
        hz = 100
    lines = [
        f"NYTProf {NYTPROF_MAJOR} {NYTPROF_MINOR}",
        f"#Perl profile database. Generated by Pynytprof on {now}",
        f":basetime={int(start_ns // 1_000_000_000)}",
        ":application=-e",
        f":perl_version={sys.version.split()[0]}",
        f":nv_size={struct.calcsize('d')}",
        ":clock_mod=cpu",
        ":ticks_per_sec=10000000",
        f":osname={platform.system().lower()}",
        f":hz={hz}",
        "!subs=1",
        "!blocks=0",
        "!leave=1",
        "!expand=0",
        "!trace=0",
        "!use_db_sub=0",
        "!compress=0",
        "!clock=1",
        "!stmts=1",
        "!slowops=2",
        "!findcaller=0",
        "!forkdepth=-1",
        "!perldb=0",
        "!nameevals=1",
        "!nameanonsubs=1",
        "!calls=1",
        "!evals=0",
    ]
    hdr = ("\n".join(lines) + "\n").encode()
    assert b"\0" not in hdr
    return hdr


def _chunk(tok: bytes, payload: bytes) -> bytes:
    """Return a NYTProf chunk without any extra processing."""
    return tok[:1] + len(payload).to_bytes(4, "little") + payload


class Writer:
    def __init__(
        self,
        path: str,
        start_ns: int | None = None,
        ticks_per_sec: int = 10_000_000,
        tracer=None,
        script_path: str | None = None,
    ):
        self._path = Path(path)
        self._fh = None
        self.start_time = time.time_ns() if start_ns is None else start_ns
        self.ticks_per_sec = ticks_per_sec
        self._start_ns = self.start_time
        self.tracer = tracer
        self.writer = self
        self.script_path = str(Path(script_path or sys.argv[0]).resolve())
        self._line_hits: dict[tuple[int, int], tuple[int, int, int]] = {}
        self._stmt_records: list[tuple[int, int, int]] = []
        self._buf: dict[bytes, bytearray] = {
            b"S": bytearray(),
            b"D": bytearray(),
            b"C": bytearray(),
        }
        self._chunk_order = [b"S", b"D", b"C", b"E"]
        self.header_size = len(_make_ascii_header(self._start_ns)) + 21
        if os.getenv("PYNYTPROF_DEBUG"):
            print("DEBUG: Writer initialized with empty buffers", file=sys.stderr)

    def _calc_start_offset(self, tag: bytes) -> int:
        offset = self.header_size
        for t in self._chunk_order:
            if t == tag:
                break
            offset += 5 + len(self._buf.get(t, b""))
        return offset

    def _debug_chunk_info(self, tag: bytes, payload: bytes, offset: int) -> None:
        if not os.getenv("PYNYTPROF_DEBUG"):
            return
        declared_len = len(payload)
        actual_len = len(payload)
        sha256 = hashlib.sha256(payload).hexdigest()
        first16 = payload[:16].hex()
        last16 = payload[-16:].hex()
        lines = [
            f"DEBUG: buffering chunk tag={tag.decode()} offset=0x{offset:x}",
            f"       declared_len={declared_len} actual_len={actual_len}",
            f"       sha256={sha256}",
            f"       first16={first16} last16={last16}",
        ]
        print("\n".join(lines), file=sys.stderr)

    def _buffer_chunk(self, tag: bytes, payload: bytes) -> None:
        offset = self._calc_start_offset(tag)
        self._buf.setdefault(tag, bytearray()).extend(payload)
        self._debug_chunk_info(tag, payload, offset)

    def _make_data_section(self) -> bytes:
        buf = bytearray()
        for fid, line, dur in self._stmt_records:
            buf += struct.pack("<BIIQ", 1, fid, line, dur)
        buf.append(0)
        return bytes(buf)

    def _write_header(self) -> None:
        banner = _make_ascii_header(self._start_ns)
        # banner is guaranteed to end with a single LF
        assert banner.endswith(b"\n")
        self._fh.write(banner)

        import os, struct, time

        if os.getenv("PYNYTPROF_DEBUG"):
            print(f"DEBUG: banner_end={banner[-9:]}", file=sys.stderr)

        start_us = int(time.time() * 1e6)
        payload = struct.pack("<QII", start_us, os.getpid(), os.getppid())
        self._fh.write(b"P" + len(payload).to_bytes(4, "little") + payload)
        self.header_size = len(banner) + 1 + 4 + len(payload)

        # emit file info for the main script immediately after the P chunk
        st = os.stat(self.script_path)
        flags = 0x10  # HAS_SRC
        f_payload = struct.pack(
            "<IIII", 0, flags, st.st_size, int(st.st_mtime)
        ) + self.script_path.encode() + b"\0"
        self._fh.write(b"F" + struct.pack("<I", len(f_payload)) + f_payload)
        if os.getenv("PYNYTPROF_DEBUG"):
            sha = hashlib.sha256(f_payload).hexdigest()
            print(
                f"DEBUG: F-chunk offset={self.header_size:#x} len={len(f_payload)} sha256={sha}",
                file=sys.stderr,
            )
        self.header_size += 1 + 4 + len(f_payload)

        if os.getenv("PYNYTPROF_DEBUG"):
            print(
                f"DEBUG: header_size={self.header_size} first_token=P",
                file=sys.stderr,
            )

    def record_line(self, fid: int, line: int, calls: int, inc: int, exc: int) -> None:
        self._line_hits[(fid, line)] = (calls, inc, exc)

    # expose the same api the C writer will have
    def write_chunk(self, token: bytes, payload: bytes):
        tag = token[:1]
        if tag in self._buf:
            if tag == b"D" and not payload:
                # tracer may emit an empty D just to signal its presence.
                # Ignore it to avoid buffering the chunk twice.
                return
            self._buffer_chunk(tag, payload)
        elif tag == b"E":
            pass  # handled on close
        else:
            # ignore unknown tags for simplicity
            pass

    def __enter__(self):
        self._fh = open(self._path, "wb")
        self._write_header()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()

    def close(self) -> None:
        if not self._fh:
            return

        if self.tracer is not None:

            def ns2ticks(ns: int) -> int:
                return ns // 100

            for line, calls in self.tracer._line_hits.items():
                self._line_hits[(0, line)] = (
                    calls,
                    ns2ticks(self.tracer._line_time_ns[line]),
                    ns2ticks(self.tracer._exc_time_ns.get(line, 0)),
                )

        import struct

        recs = []
        for (fid, line), (calls, inc, exc) in self._line_hits.items():
            recs.append(struct.pack("<IIIQQ", fid, line, calls, inc, exc))
        s_payload = b"".join(recs)
        if s_payload:
            self._buffer_chunk(b"S", s_payload)
        if self._stmt_records:
            payload = self._make_data_section()
            if os.getenv("PYNYTPROF_DEBUG"):
                off = self._calc_start_offset(b"D")
                self._debug_chunk_info(b"D", payload, off)
            self._buf[b"D"] = bytearray(payload)
        elif not self._buf[b"D"]:
            payload = b"\x00"
            if os.getenv("PYNYTPROF_DEBUG"):
                off = self._calc_start_offset(b"D")
                self._debug_chunk_info(b"D", payload, off)
            self._buf[b"D"] = bytearray(payload)
        if os.getenv("PYNYTPROF_DEBUG"):
            import sys

            summary = {
                tag.decode(): len(self._buf.get(tag, b""))
                for tag in [b"S", b"D", b"C", b"E"]
            }
            print("FINAL CHUNKS:", summary, file=sys.stderr)

        chunk_lengths = []
        for idx, tag in enumerate([b"S", b"D", b"C", b"E"], start=1):
            payload = self._buf.get(tag, b"")
            payload = payload.replace(b"\n", b"\x01")
            length = len(payload)
            while b"\n" in length.to_bytes(4, "little"):
                payload += b"\x00"
                length = len(payload)
            chunk_lengths.append(length)
            off = self._fh.tell()
            self._fh.write(tag)
            self._fh.write(length.to_bytes(4, "little"))
            self._fh.write(payload)
            if os.getenv("PYNYTPROF_DEBUG"):
                # Read back the first payload byte
                self._fh.flush()
                with open(self._fh.name, "rb") as f:
                    f.seek(off + 5)
                    first = f.read(1)
                print(
                    f"DEBUG: chunk {idx} tag={tag.decode()}   offset=0x{off:x}   "
                    f"declared_len={len(payload)}   first_byte={first!r}",
                    file=sys.stderr,
                )
        if os.getenv("PYNYTPROF_DEBUG"):
            eof = self._fh.tell()
            expected = self.header_size + sum(5 + l for l in chunk_lengths)
            total_chunks = sum(chunk_lengths)
            print(f"DEBUG: EOF at offset=0x{eof:x}", file=sys.stderr)
            print(
                f"DEBUG: expected_size={expected} sum_chunk_lengths={total_chunks}",
                file=sys.stderr,
            )
            if eof != expected:
                print("WARNING: file size mismatch", file=sys.stderr)

        self._fh.close()
        self._fh = None

    def _write_chunk(self, tag: bytes, payload: bytes) -> None:
        data = tag[:1]
        if os.getenv("PYNYTPROF_DEBUG"):
            print(f"DEBUG: about to write raw data of length={len(data)}", file=sys.stderr)
        self._fh.write(data)
        data = len(payload).to_bytes(4, "little")
        if os.getenv("PYNYTPROF_DEBUG"):
            print(f"DEBUG: about to write raw data of length={len(data)}", file=sys.stderr)
        self._fh.write(data)
        if payload:
            data = payload
            if os.getenv("PYNYTPROF_DEBUG"):
                print(f"DEBUG: about to write raw data of length={len(data)}", file=sys.stderr)
            self._fh.write(data)


def write(
    out_path: str,
    files: list[tuple[int, int, int, int, str]],
    defs: list,
    calls: list,
    lines: list[tuple[int, int, int, int, int]],
    start_ns: int,
    ticks_per_sec: int,
) -> None:
    """Write NYTProf file purely in Python."""
    path = Path(out_path)
    with path.open("wb") as f:
        banner = _make_ascii_header(start_ns)
        f.write(banner)
        import os, struct, time
        start_us = int(time.time() * 1e6)
        payload = struct.pack('<QII', start_us, os.getpid(), os.getppid())
        f.write(b'P' + struct.pack('<I', len(payload)) + payload)
        if not files:
            script = Path(sys.argv[0]).resolve()
            st = script.stat()
            files = [(0, 0x10, st.st_size, int(st.st_mtime), str(script))]

        s_payload = b"".join(
            struct.pack("<IIIQQ", fid, line, calls_v, inc // 100, exc // 100)
            for fid, line, calls_v, inc, exc in lines
        )
        f.write(_chunk(b"S", s_payload))

        d_payload = b""
        c_payload = b""
        if defs:
            if len(defs[0]) == 3:  # simple sub table
                d_payload = b"".join(
                    struct.pack("<II", sid, flags) + name.encode() + b"\0"
                    for sid, flags, name in defs
                )
                c_payload = b"".join(
                    struct.pack("<IIIQQ", cs, ce, cnt, t, st) for cs, ce, cnt, t, st in calls
                )
            else:
                d_payload = b"".join(
                    struct.pack("<IIII", sid, fid, sl, el) + name.encode() + b"\0"
                    for sid, fid, sl, el, name in defs
                )
                c_payload = b"".join(
                    struct.pack("<IIIQQ", fid, line, sid, inc // 100, exc // 100)
                    for fid, line, sid, inc, exc in calls
                )
        if d_payload:
            f.write(_chunk(b"D", d_payload))
        if c_payload:
            f.write(_chunk(b"C", c_payload))

        f.write(_chunk(b"E", b""))
