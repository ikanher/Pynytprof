# Simple pure-Python NYTProf writer fallback
from __future__ import annotations

from pathlib import Path
import struct
import time
import os
import sys
import platform
import datetime
from email.utils import format_datetime
from importlib import resources
import re

try:  # Python 3.9+
    _version_text = resources.files(__package__).joinpath("nytp_version.h").read_text()
except AttributeError:  # pragma: no cover - fallback for Python < 3.9
    _version_text = resources.read_text(__package__, "nytp_version.h")
_major_match = re.search(r"NYTPROF_MAJOR\s+(\d+)", _version_text)
_minor_match = re.search(r"NYTPROF_MINOR\s+(\d+)", _version_text)
NYTPROF_MAJOR = int(_major_match.group(1)) if _major_match else 5
NYTPROF_MINOR = int(_minor_match.group(1)) if _minor_match else 0


def _make_ascii_header(start_ns: int) -> bytes:
    now = format_datetime(datetime.datetime.now(datetime.timezone.utc))
    try:
        hz = os.sysconf("SC_CLK_TCK")  # type: ignore[arg-type]
    except (AttributeError, ValueError, OSError):
        hz = 100
    lines = [
        f"NYTProf {NYTPROF_MAJOR} {NYTPROF_MINOR}",
        f"#Perl profile database. Generated by Pynytprof on {now}",
        f":basetime={int(start_ns // 1_000_000_000)}",
        ":application=-e",
        f":perl_version={sys.version.split()[0]}",
        f":nv_size={struct.calcsize('d')}",
        ":clock_mod=cpu",
        ":ticks_per_sec=10000000",
        f":osname={platform.system().lower()}",
        f":hz={hz}",
        "!subs=1",
        "!blocks=0",
        "!leave=1",
        "!expand=0",
        "!trace=0",
        "!use_db_sub=0",
        "!compress=0",
        "!clock=1",
        "!stmts=1",
        "!slowops=2",
        "!findcaller=0",
        "!forkdepth=-1",
        "!perldb=0",
        "!nameevals=1",
        "!nameanonsubs=1",
        "!calls=1",
        "!evals=0",
    ]
    hdr = ("\n".join(lines) + "\n").encode()
    assert b"\0" not in hdr
    return hdr


def _chunk(tok: bytes, payload: bytes) -> bytes:
    """Return a NYTProf chunk without any extra processing."""
    return tok[:1] + len(payload).to_bytes(4, "little") + payload


class Writer:
    def __init__(
        self, path: str, start_ns: int | None = None, ticks_per_sec: int = 10_000_000, tracer=None
    ):
        self._path = Path(path)
        self._fh = None
        self.start_time = time.time_ns() if start_ns is None else start_ns
        self.ticks_per_sec = ticks_per_sec
        self._start_ns = self.start_time
        self.tracer = tracer
        self.writer = self

    # expose the same api the C writer will have
    def write_chunk(self, token: bytes, payload: bytes):
        self._write_chunk(token, payload)

    def __enter__(self):
        self._fh = open(self._path, "wb")
        self._write_ascii_header()
        return self

    def __exit__(self, exc_type, exc, tb):
        if self._fh:
            if self.tracer is not None:
                import struct

                ns2ticks = lambda ns: ns // 100
                payload = b"".join(
                    struct.pack(
                        "<IIIQQ",
                        0,
                        line,
                        calls,
                        ns2ticks(self.tracer._line_time_ns[line]),
                        ns2ticks(self.tracer._exc_time_ns.get(line, 0)),
                    )
                    for line, calls in self.tracer._line_hits.items()
                )
                if payload:
                    self.writer.write_chunk(b"S", payload)

                if self.tracer._calls:
                    id_map = {
                        n: i
                        for i, n in enumerate(
                            sorted({n for pair in self.tracer._calls for n in pair})
                        )
                    }
                    d_parts = [
                        struct.pack("<II", sid, 0) + name.encode() + b"\0"
                        for name, sid in id_map.items()
                    ]
                    if d_parts:
                        self.writer.write_chunk(b"D", b"".join(d_parts))
                    c_parts = []
                    for (caller, callee), cnt in self.tracer._calls.items():
                        inc = ns2ticks(self.tracer._edge_time_ns.get((caller, callee), 0))
                        c_parts.append(
                            struct.pack("<IIIQQ", id_map[caller], id_map[callee], cnt, inc, inc)
                        )
                    if c_parts:
                        self.writer.write_chunk(b"C", b"".join(c_parts))
            self._write_chunk(b"E", b"")
            self._fh.close()
        self._fh = None

    def close(self) -> None:
        if self._fh:
            if self.tracer is not None:
                import struct

                ns2ticks = lambda ns: ns // 100
                payload = b"".join(
                    struct.pack(
                        "<IIIQQ",
                        0,
                        line,
                        calls,
                        ns2ticks(self.tracer._line_time_ns[line]),
                        ns2ticks(self.tracer._exc_time_ns.get(line, 0)),
                    )
                    for line, calls in self.tracer._line_hits.items()
                )
                if payload:
                    self.writer.write_chunk(b"S", payload)
                if self.tracer._calls:
                    id_map = {
                        n: i
                        for i, n in enumerate(
                            sorted({n for pair in self.tracer._calls for n in pair})
                        )
                    }
                    d_parts = [
                        struct.pack("<II", sid, 0) + name.encode() + b"\0"
                        for name, sid in id_map.items()
                    ]
                    if d_parts:
                        self.writer.write_chunk(b"D", b"".join(d_parts))
                    c_parts = []
                    for (caller, callee), cnt in self.tracer._calls.items():
                        inc = ns2ticks(self.tracer._edge_time_ns.get((caller, callee), 0))
                        c_parts.append(
                            struct.pack("<IIIQQ", id_map[caller], id_map[callee], cnt, inc, inc)
                        )
                    if c_parts:
                        self.writer.write_chunk(b"C", b"".join(c_parts))
            self._write_chunk(b"E", b"")
            self._fh.close()
        self._fh = None

    def _write_ascii_header(self) -> None:
        now = format_datetime(datetime.datetime.now(datetime.timezone.utc))
        try:
            hz = os.sysconf("SC_CLK_TCK")  # type: ignore[arg-type]
        except (AttributeError, ValueError, OSError):
            hz = 100
        lines = [
            f"NYTProf {NYTPROF_MAJOR} {NYTPROF_MINOR}",
            f"#Perl profile database. Generated by Pynytprof on {now}",
            f":basetime={int(self._start_ns // 1_000_000_000)}",
            ":application=-e",
            f":perl_version={sys.version.split()[0]}",
            f":nv_size={struct.calcsize('d')}",
            ":clock_mod=cpu",
            ":ticks_per_sec=10000000",
            f":osname={platform.system().lower()}",
            f":hz={hz}",
            "!subs=1",
            "!blocks=0",
            "!leave=1",
            "!expand=0",
            "!trace=0",
            "!use_db_sub=0",
            "!compress=0",
            "!clock=1",
            "!stmts=1",
            "!slowops=2",
            "!findcaller=0",
            "!forkdepth=-1",
            "!perldb=0",
            "!nameevals=1",
            "!nameanonsubs=1",
            "!calls=1",
            "!evals=0",
        ]
        hdr = ("\n".join(lines) + "\n").encode()
        assert b"\0" not in hdr
        self._fh.write(hdr)

    def _write_chunk(self, tag: bytes, payload: bytes) -> None:
        self._fh.write(tag)
        self._fh.write(struct.pack("<I", len(payload)))
        if payload:
            self._fh.write(payload)


def write(
    out_path: str,
    files: list[tuple[int, int, int, int, str]],
    defs: list,
    calls: list,
    lines: list[tuple[int, int, int, int, int]],
    start_ns: int,
    ticks_per_sec: int,
) -> None:
    """Write NYTProf file purely in Python."""
    path = Path(out_path)
    with path.open("wb") as f:
        f.write(_make_ascii_header(start_ns))
        if not files:
            script = Path(sys.argv[0]).resolve()
            st = script.stat()
            files = [(0, 0x10, st.st_size, int(st.st_mtime), str(script))]
        d_payload = b""
        c_payload = b""
        if defs:
            if len(defs[0]) == 3:  # simple sub table
                d_payload = b"".join(
                    struct.pack("<II", sid, flags) + name.encode() + b"\0"
                    for sid, flags, name in defs
                )
                c_payload = b"".join(
                    struct.pack("<IIIQQ", cs, ce, cnt, t, st) for cs, ce, cnt, t, st in calls
                )
            else:
                d_payload = b"".join(
                    struct.pack("<IIII", sid, fid, sl, el) + name.encode() + b"\0"
                    for sid, fid, sl, el, name in defs
                )
                c_payload = b"".join(
                    struct.pack("<IIIQQ", fid, line, sid, inc // 100, exc // 100)
                    for fid, line, sid, inc, exc in calls
                )
        f.write(_chunk(b"D", d_payload))
        f.write(_chunk(b"C", c_payload))
        s_payload = b"".join(
            struct.pack("<IIIQQ", fid, line, calls_v, inc // 100, exc // 100)
            for fid, line, calls_v, inc, exc in lines
        )
        f.write(_chunk(b"S", s_payload))
        f.write(_chunk(b"E", b""))
